---
layout: default
title: Kinect Schnittstelle
menupos: 3
---
{% include base.html %}

<div class="jumbotron">
    <h1>Kinect</h1>

    
	Zittern verhindern, eigener Klick implementiert, 
</div>

<h2>Umwandlung der Hand-Koordinaten</h2>
    <div class="clearfix">
    <a href="{{base}}/img/ebene_skeleton.png" class="lightbox-link" data-lightbox="ebene_skeleton"> 
        <img class="img-responsive img-thumbnail lfloat-sm-6"  width="898" height="674" src="{{base}}/img/ebene_skeleton.png" alt="ebene_skeleton.png"/>
    </a>
    <p>
    Um die Bedienung unabhängig von der Position des Benutzers zu machen, haben wir eine neue Ebene abhängig vom Benutzer erstellt.<br/>
    Diese wird aus den Koordinaten der linken und rechten Schulter sowie des Torsos durch einen Basiswechsel berechnet.<br/>
    Linke Schulter \((S_1)\), rechte Schulter \((S_2)\) und Torso \((T)\):
    $$
        S_1 = \begin{pmatrix}
        S_{10} \\ S_{11} \\S_{12}
        \end{pmatrix}
        \quad
        S_2 = \begin{pmatrix}
        S_{20} \\ S_{21} \\S_{22}
        \end{pmatrix}
        \quad
        T= \begin{pmatrix}
        T_1\\T_2\\T_3
        \end{pmatrix}
    $$
    Daraus ergibt sich die folgende Basiswechselmatrix:
    $$
        M_{B \rightarrow E} = \left( \begin{array}{ccc}
        S_{20} - S_{10} & 0 & S_{22}-S_{12} \\
        0 & X & 0 \\
        S_{22} - S_{12} & 0 & S_{10}-S_{20} \\
        \end{array}
        \right)
    $$
    Wobei \(X\) die Länge zwischen den beiden Schulterpunkten ist.<br/>
    Die umgerechnete Handposition \((H_{	neu})\) erhält man aus der alten Handposition \((H)\) wie folgt:
    $$
        H_{neu} = M_{B \rightarrow E}^{-1} \cdot \begin{pmatrix}
        H_1 - T_1\\ H_2-T_2\\H_3-T_3        
        \end{pmatrix}
    $$
    Hierbei wird der Torso \((T)\) der Ursprung des neuen Koordinatensystems.
    </p>
    </div>
    <h2>Zittern des Cursors verhindern</h2>
    Benutzt man direkt die umgerechneten Handkoordinaten der Kinect als Cursor im Menü oder Spiel verwendet, fällt einem auf, dass der Cursor sehr unruhig ist und zu zittern scheint. Dies lässt das Bild unruhig erscheinen, da der Cursor sich ständig bewegt, obwohl man selbst das Gefühl hat, seine Hand ruhig zu halten.<br/>
    Um das Zittern zu verhindern, speichern wir die letzten 10 Positionen des Cursors und berechnen deren Durchschnittswert. Der Cursor wird nur bewegt, wenn sich der berechnete Durchschnittswert signifikant von dem vorigen unterscheidet.

	<h2>Klick-Geste</h2>
    <p>Um einen Maulwurf in dem Hau den Maulwurf Spiel zu treffen, muss der Benutzer eine Klick Bewegung ausführen. Eine solche Klick-Geste wird bereits von OpenNi zur Verfügung gestellt, jedoch reagiert diese erst, wenn man den Arm fast ganz ausstreckt.<br/>
    Dies ist äußerst ungeeignet für das Hau den Maulwurf Spiel, da hier sehr oft und schnell geklickt werden muss. Daher haben wir eine eigene Klick-Geste entwickelt, welche früher reagiert und nur eine kleine Bewegung benötigt um einen Klick auszulösen.</p>
    <h3> Die Klick-Geste Implementierung</h3>
<pre class="line-numbers">
<code class="language-cpp">
// Add the new point and its timestamp to the queue.
positions_.emplace_back(elapsed_time_, point.Y);

// Remove all points that are too old.
while (!positions_.empty() && positions_.front().first+max_delay_ &lt; elapsed_time_)
    positions_.pop_front();

// Check if enough movement happened.
float sum = 0.0;
float prev = positions_.front().second;
for (auto const & p : positions_) {
    if (p.second &gt; prev) {
        sum += abs(p.second - prev);
        prev = p.second;
    }
}

// To prevent rapid clicking, only fire handle_click_() if no click happened just before.
if (clicked_) {
    if (sum &lt; threshold_) {
        clicked_ = false;
    }
} else {
    if (sum &gt;= threshold_) {
        clicked_ = true;
        handle_click_();
    }
}</code>
</pre>



